import os
import datetime
from dotenv import load_dotenv
import json

# C√°c th∆∞ vi·ªán c·ªßa Google ƒë·ªÉ x√°c th·ª±c v√† t∆∞∆°ng t√°c v·ªõi Calendar
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

# C√°c th∆∞ vi·ªán c·ªßa LangChain ƒë·ªÉ x√¢y d·ª±ng Agent
from langchain.agents import Tool, create_react_agent, AgentExecutor
from langchain_core.prompts import PromptTemplate
from langchain_google_genai import ChatGoogleGenerativeAI

# T·∫£i c√°c bi·∫øn m√¥i tr∆∞·ªùng t·ª´ file .env
load_dotenv()

# --- PH·∫¶N 1: C√îNG C·ª§ ƒê·ªåC L·ªäCH (PHI√äN B·∫¢N CHO M√ÅY LOCAL) ---

# ƒê·ªãnh nghƒ©a ph·∫°m vi truy c·∫≠p v√†o Google Calendar
SCOPES = ["https://www.googleapis.com/auth/calendar.readonly"]
CREDENTIALS_PATH = "credentials.json"
TOKEN_PATH = "token.json"  # File n√†y s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông t·∫°o ra
FLASHCARDS_FILE = "flashcards.json"

# C√¥ng c·ª• ƒë·ªçc l·ªãch t·ª´ Google Calendar
def get_calendar_events(days_to_check_str: str) -> str:
    """
    C√¥ng c·ª• ƒë·ªÉ ki·ªÉm tra c√°c s·ª± ki·ªán tr√™n Google Calendar.
    ƒê·∫ßu v√†o l√† m·ªôt chu·ªói k√Ω t·ª± ch·ª©a s·ªë ng√†y c·∫ßn ki·ªÉm tra trong t∆∞∆°ng lai.
    """
    creds = None
    # File token.json l∆∞u tr·ªØ token c·ªßa ng∆∞·ªùi d√πng sau l·∫ßn ƒëƒÉng nh·∫≠p ƒë·∫ßu ti√™n
    if os.path.exists(TOKEN_PATH):
        creds = Credentials.from_authorized_user_file(TOKEN_PATH, SCOPES)
    
    # N·∫øu kh√¥ng c√≥ credentials h·ª£p l·ªá, y√™u c·∫ßu ng∆∞·ªùi d√πng ƒëƒÉng nh·∫≠p
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            # D√≤ng n√†y s·∫Ω t·ª± ƒë·ªông m·ªü tr√¨nh duy·ªát ƒë·ªÉ b·∫°n ƒëƒÉng nh·∫≠p v√† c·∫•p quy·ªÅn
            flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_PATH, SCOPES)
            creds = flow.run_local_server(port=0)
        # L∆∞u credentials cho nh·ªØng l·∫ßn ch·∫°y sau
        with open(TOKEN_PATH, "w") as token:
            token.write(creds.to_json())

    try:
        # Chuy·ªÉn ƒë·ªïi ƒë·∫ßu v√†o t·ª´ chu·ªói sang s·ªë
        days_to_check = int(days_to_check_str)
        service = build("calendar", "v3", credentials=creds)

        # L·∫•y th·ªùi gian hi·ªán t·∫°i v√† t√≠nh th·ªùi gian k·∫øt th√∫c
        now = datetime.datetime.utcnow().isoformat() + "Z"
        end_date = (datetime.datetime.utcnow() + datetime.timedelta(days=days_to_check)).isoformat() + "Z"

        # G·ªçi Google Calendar API
        events_result = service.events().list(
            calendarId="primary", timeMin=now, timeMax=end_date,
            maxResults=15, singleEvents=True, orderBy="startTime"
        ).execute()
        events = events_result.get("items", [])

        if not events:
            return "Kh√¥ng t√¨m th·∫•y s·ª± ki·ªán n√†o trong l·ªãch c·ªßa b·∫°n."

        event_list = "ƒê√¢y l√† c√°c s·ª± ki·ªán s·∫Øp t·ªõi c·ªßa b·∫°n:\n"
        for event in events:
            start = event["start"].get("dateTime", event["start"].get("date"))
            start_dt = datetime.datetime.fromisoformat(start.replace("Z", "+00:00"))
            event_list += f"- {start_dt.strftime('%A, %d/%m/%Y l√∫c %H:%M')}: {event['summary']}\n"
        
        return event_list
    except Exception as e:
        return f"ƒê√£ x·∫£y ra l·ªói: {e}"

# C√îNG C·ª§ T√åM KI·∫æM T√ÄI LI·ªÜU H·ªåC T·∫¨P
def search_study_materials(query: str) -> str:
    """
    C√¥ng c·ª• t√¨m ki·∫øm t√†i li·ªáu h·ªçc t·∫≠p tr·ª±c tuy·∫øn.
    R·∫•t h·ªØu √≠ch ƒë·ªÉ t√¨m c√°c b√†i gi·∫£ng, video, ho·∫∑c b√†i vi·∫øt v·ªÅ m·ªôt ch·ªß ƒë·ªÅ c·ª• th·ªÉ.
    """
    try:
        api_key = os.getenv("CUSTOM_SEARCH_API_KEY")
        search_engine_id = os.getenv("SEARCH_ENGINE_ID")

        # X√¢y d·ª±ng d·ªãch v·ª• t√¨m ki·∫øm
        service = build("customsearch", "v1", developerKey=api_key)
        
        # Th·ª±c hi·ªán t√¨m ki·∫øm
        result = service.cse().list(q=query, cx=search_engine_id, num=3).execute()
        
        if "items" not in result:
            return "Kh√¥ng t√¨m th·∫•y t√†i li·ªáu n√†o ph√π h·ª£p."

        # ƒê·ªãnh d·∫°ng k·∫øt qu·∫£
        search_results = f"ƒê√¢y l√† m·ªôt v√†i t√†i li·ªáu h·ªØu √≠ch cho ch·ªß ƒë·ªÅ '{query}':\n"
        for item in result["items"]:
            search_results += f"- Ti√™u ƒë·ªÅ: {item['title']}\n"
            search_results += f"  Link: {item['link']}\n"
            search_results += f"  M√¥ t·∫£: {item.get('snippet', 'Kh√¥ng c√≥ m√¥ t·∫£.')}\n\n"
        
        return search_results

    except HttpError as e:
        # X·ª≠ l√Ω l·ªói n·∫øu API key ho·∫∑c Search Engine ID sai
        if e.resp.status == 400 or e.resp.status == 403:
            return "L·ªói: API Key ho·∫∑c Search Engine ID kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i file .env."
        return f"ƒê√£ x·∫£y ra l·ªói khi t√¨m ki·∫øm: {e}"
    except Exception as e:
        return f"ƒê√£ x·∫£y ra m·ªôt l·ªói kh√¥ng x√°c ƒë·ªãnh: {e}"

# C√îNG C·ª§ QU·∫¢N L√ù TH·∫∫ GHI NH·ªö ---
def manage_flashcards(action: str, topic: str = "", front: str = "", back: str = "") -> str:
    """
    C√¥ng c·ª• ƒë·ªÉ qu·∫£n l√Ω th·∫ª ghi nh·ªõ (flashcards). 
    C√°c h√†nh ƒë·ªông (action) bao g·ªìm: 'add' (th√™m th·∫ª), 'get' (l·∫•y th·∫ª theo ch·ªß ƒë·ªÅ), v√† 'list_topics' (li·ªát k√™ c√°c ch·ªß ƒë·ªÅ).
    - ƒê·ªÉ 'add': c·∫ßn c√≥ 'topic', 'front', v√† 'back'.
    - ƒê·ªÉ 'get': ch·ªâ c·∫ßn 'topic'.
    - ƒê·ªÉ 'list_topics': kh√¥ng c·∫ßn tham s·ªë kh√°c.
    """
    # ƒê·ªçc d·ªØ li·ªáu th·∫ª ghi nh·ªõ hi·ªán c√≥
    if os.path.exists(FLASHCARDS_FILE):
        with open(FLASHCARDS_FILE, 'r', encoding='utf-8') as f:
            flashcards = json.load(f)
    else:
        flashcards = {}

    # X·ª≠ l√Ω c√°c h√†nh ƒë·ªông
    if action == "add":
        if not all([topic, front, back]):
            return "L·ªói: ƒê·ªÉ th√™m th·∫ª, c·∫ßn cung c·∫•p ƒë·ªß topic, front, v√† back."
        
        if topic not in flashcards:
            flashcards[topic] = []
        
        flashcards[topic].append({"front": front, "back": back})
        
        # L∆∞u l·∫°i v√†o file
        with open(FLASHCARDS_FILE, 'w', encoding='utf-8') as f:
            json.dump(flashcards, f, ensure_ascii=False, indent=4)
        return f"ƒê√£ th√™m th√†nh c√¥ng th·∫ª ghi nh·ªõ v√†o ch·ªß ƒë·ªÅ '{topic}'."

    elif action == "get":
        if not topic:
            return "L·ªói: C·∫ßn cung c·∫•p topic ƒë·ªÉ l·∫•y th·∫ª ghi nh·ªõ."
        
        cards = flashcards.get(topic)
        if not cards:
            return f"Kh√¥ng t√¨m th·∫•y th·∫ª ghi nh·ªõ n√†o cho ch·ªß ƒë·ªÅ '{topic}'."
        
        response = f"C√°c th·∫ª ghi nh·ªõ cho ch·ªß ƒë·ªÅ '{topic}':\n"
        for i, card in enumerate(cards, 1):
            response += f"{i}. M·∫∑t tr∆∞·ªõc: {card['front']} | M·∫∑t sau: {card['back']}\n"
        return response

    elif action == "list_topics":
        if not flashcards:
            return "B·∫°n ch∆∞a c√≥ ch·ªß ƒë·ªÅ th·∫ª ghi nh·ªõ n√†o."
        
        topics = list(flashcards.keys())
        return f"C√°c ch·ªß ƒë·ªÅ th·∫ª ghi nh·ªõ b·∫°n ƒëang c√≥: {', '.join(topics)}"

    else:
        return f"L·ªói: H√†nh ƒë·ªông '{action}' kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£. Ch·ªâ c√≥ th·ªÉ d√πng 'add', 'get', 'list_topics'."

# --- PH·∫¶N 2: THI·∫æT L·∫¨P V√Ä CH·∫†Y AGENT ---

def main():
    """H√†m ch√≠nh ƒë·ªÉ thi·∫øt l·∫≠p v√† ch·∫°y v√≤ng l·∫∑p t∆∞∆°ng t√°c v·ªõi AI Mentor."""
    
    print("ü§ñ Kh·ªüi t·∫°o AI Mentor...")

    # 1. T·∫°o Tool
    # C√¥ng c·ª• ƒë·ªçc l·ªãch t·ª´ Google Calendar
    calendar_tool = Tool(
        name="Google_Calendar_Reader",
        func=get_calendar_events,
        description="R·∫•t h·ªØu √≠ch ƒë·ªÉ t√¨m hi·ªÉu v·ªÅ c√°c s·ª± ki·ªán, k·ª≥ thi, ho·∫∑c h·∫°n ch√≥t s·∫Øp t·ªõi t·ª´ Google Calendar. ƒê·∫ßu v√†o c·ªßa c√¥ng c·ª• n√†y l√† m·ªôt con s·ªë, ƒë·∫°i di·ªán cho s·ªë ng√†y c·∫ßn ki·ªÉm tra trong t∆∞∆°ng lai.",
    )
    # C√¥ng c·ª• t√¨m ki·∫øm t√†i li·ªáu h·ªçc t·∫≠p
    search_tool = Tool(
        name="Study_Material_Searcher",
        func=search_study_materials,
        description="R·∫•t h·ªØu √≠ch ƒë·ªÉ t√¨m c√°c b√†i gi·∫£ng, video, ho·∫∑c b√†i vi·∫øt v·ªÅ m·ªôt ch·ªß ƒë·ªÅ h·ªçc t·∫≠p c·ª• th·ªÉ. V√≠ d·ª• ƒë·∫ßu v√†o: 'b√†i gi·∫£ng v·ªÅ t√≠ch ph√¢n l·ªõp 12'.",
    )
    # C√¥ng c·ª• qu·∫£n l√Ω th·∫ª ghi nh·ªõ
    flashcard_tool = Tool(
    name="Flashcard_Manager",
    # Lambda function n√†y s·∫Ω t√¨m v√† tr√≠ch xu·∫•t ph·∫ßn JSON c·ªët l√µi tr∆∞·ªõc khi x·ª≠ l√Ω
    func=lambda params: manage_flashcards(**json.loads(params[params.find('{') : params.rfind('}')+1])),
    description="""C√¥ng c·ª• ƒë·ªÉ qu·∫£n l√Ω th·∫ª ghi nh·ªõ. H·ªØu √≠ch ƒë·ªÉ th√™m, xem l·∫°i, ho·∫∑c li·ªát k√™ c√°c th·∫ª ghi nh·ªõ.
        ƒê·∫ßu v√†o PH·∫¢I l√† m·ªôt chu·ªói JSON h·ª£p l·ªá.
        V√≠ d·ª•:
        - ƒê·ªÉ th√™m th·∫ª: {"action": "add", "topic": "T√™n ch·ªß ƒë·ªÅ", "front": "N·ªôi dung m·∫∑t tr∆∞·ªõc", "back": "N·ªôi dung m·∫∑t sau"}
        - ƒê·ªÉ xem th·∫ª: {"action": "get", "topic": "T√™n ch·ªß ƒë·ªÅ"}
        - ƒê·ªÉ li·ªát k√™ ch·ªß ƒë·ªÅ: {"action": "list_topics"}
        """,
    )
    
    # Danh s√°ch c√°c c√¥ng c·ª•
    tools = [calendar_tool, search_tool, flashcard_tool]

    # 2. T·∫°o Prompt Template
    prompt_template = """
    B·∫°n l√† AI Mentor, m·ªôt tr·ª£ l√Ω h·ªçc t·∫≠p th√¥ng minh. M·ª•c ti√™u c·ªßa b·∫°n l√† tr·∫£ l·ªùi c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng b·∫±ng ti·∫øng Vi·ªát.
    B·∫°n c√≥ quy·ªÅn truy c·∫≠p v√†o c√°c c√¥ng c·ª• sau ƒë√¢y: {tools}
    ƒê·ªÉ s·ª≠ d·ª•ng m·ªôt c√¥ng c·ª•, b·∫°n PH·∫¢I tu√¢n th·ªß nghi√™m ng·∫∑t ƒë·ªãnh d·∫°ng sau:
    ```
    Thought: Suy nghƒ© c·ªßa b·∫°n v·ªÅ vi·ªác c√≥ c·∫ßn s·ª≠ d·ª•ng c√¥ng c·ª• hay kh√¥ng.
    Action: T√™n c·ªßa c√¥ng c·ª• c·∫ßn d√πng, PH·∫¢I l√† M·ªòT trong c√°c t√™n sau: {tool_names}.
    Action Input: ƒê·∫ßu v√†o cho c√¥ng c·ª•.
    Observation: K·∫øt qu·∫£ tr·∫£ v·ªÅ t·ª´ c√¥ng c·ª•.
    ```
    Khi b·∫°n ƒë√£ c√≥ ƒë·ªß th√¥ng tin, h√£y d√πng ƒë·ªãnh d·∫°ng sau:
    ```
    Thought: B√¢y gi·ªù t√¥i ƒë√£ c√≥ ƒë·ªß th√¥ng tin ƒë·ªÉ ƒë∆∞a ra c√¢u tr·∫£ l·ªùi cu·ªëi c√πng.
    Final Answer: [C√¢u tr·∫£ l·ªùi cu·ªëi c√πng c·ªßa b·∫°n ·ªü ƒë√¢y]
    ```
    B·∫Øt ƒë·∫ßu n√†o!
    Question: {input}
    Thought: {agent_scratchpad}
    """
    prompt = PromptTemplate.from_template(template=prompt_template)

    # 3. Thi·∫øt l·∫≠p LLM v√† Agent
    llm = ChatGoogleGenerativeAI(model="gemini-1.5-flash", temperature=0)
    agent = create_react_agent(llm=llm, tools=tools, prompt=prompt)
    agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)

    print("‚úÖ AI Mentor ƒë√£ s·∫µn s√†ng! G√µ 'quit' ƒë·ªÉ tho√°t.")
    
    # 4. T·∫°o v√≤ng l·∫∑p t∆∞∆°ng t√°c
    while True:
        user_input = input("B·∫°n: ")
        if user_input.lower() == 'quit':
            print("üëã T·∫°m bi·ªát!")
            break
        
        response = agent_executor.invoke({"input": user_input})
        print(f"AI Mentor: {response['output']}")

if __name__ == "__main__":
    main()